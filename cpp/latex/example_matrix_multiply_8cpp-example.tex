\hypertarget{example_matrix_multiply_8cpp-example}{}\section{example\+\_\+matrix\+\_\+multiply.\+cpp}

\begin{DoxyCodeInclude}
\textcolor{preprocessor}{#include "\hyperlink{main_8hpp}{yacx/main.hpp}"}

\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <array>}
\textcolor{preprocessor}{#include <cstdio>}
\textcolor{preprocessor}{#include <ctime>}
\textcolor{preprocessor}{#include <functional>}
\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <iterator>}
\textcolor{preprocessor}{#include <random>}
\textcolor{preprocessor}{#include <string>}

\textcolor{keyword}{using} \hyperlink{classyacx_1_1_source}{yacx::Source}, yacx::KernelArg, yacx::Kernel, yacx::Options, yacx::Device,
    yacx::load, yacx::KernelTime;

\textcolor{keywordtype}{void} compare(\textcolor{keywordtype}{float} *lhs, \textcolor{keywordtype}{float} *rhs, \textcolor{keywordtype}{int} width) \{
  \textcolor{keywordtype}{int} errors = 0;
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i\{0\}; i < width; i += 1) \{
    \textcolor{comment}{// printf("[%d] expected %f : actually %f\(\backslash\)n", i, lhs[i], rhs[i]);}
    \textcolor{keywordflow}{if} ((lhs[i] - rhs[i]) != 0) \{
      errors += 1;
    \}
  \}
  \textcolor{keywordflow}{if} (errors > 0)
    printf(\textcolor{stringliteral}{"\(\backslash\)u001b[31m%d errors occured, out of %d values.\(\backslash\)u001b[0m\(\backslash\)n"}, errors,
           width);
  \textcolor{keywordflow}{else}
    printf(\textcolor{stringliteral}{"\(\backslash\)u001b[32mno errors occured.\(\backslash\)u001b[0m\(\backslash\)n"});
\}

std::function<bool(const float &, const float &)> comparator =
    [](\textcolor{keyword}{const} \textcolor{keywordtype}{float} &left, \textcolor{keyword}{const} \textcolor{keywordtype}{float} &right) \{
      \textcolor{comment}{// double epsilon\{1.0E-8\};}
      \textcolor{keywordtype}{double} epsilon\{1\};
      \textcolor{keywordflow}{return} (abs(left - right) < epsilon);
    \};

\textcolor{keyword}{template} <\textcolor{keyword}{class} Iter>
\textcolor{keywordtype}{void} fill(Iter start, Iter end, \textcolor{keywordtype}{int} min = 0, \textcolor{keywordtype}{int} max = 100) \{
  \textcolor{keyword}{static} std::random\_device rd;
  \textcolor{keyword}{static} std::mt19937 mte(rd());

  std::uniform\_int\_distribution<int> dist(min, max);

  std::generate(start, end, [&]() \{ \textcolor{keywordflow}{return} dist(mte); \});
\}

\textcolor{keywordtype}{void} MatrixMulSeq(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *M, \textcolor{keyword}{const} \textcolor{keywordtype}{float} *N, \textcolor{keywordtype}{float} *P, \textcolor{keywordtype}{size\_t} width) \{
  \textcolor{keywordtype}{size\_t} Col, Row, k;
  \textcolor{keywordflow}{for} (Col = 0; Col < width; ++Col)
    \textcolor{keywordflow}{for} (Row = 0; Row < width; ++Row) \{
      \textcolor{keywordtype}{float} sum = 0;
      \textcolor{keywordflow}{for} (k = 0; k < width; k += 1) \{
        sum += M[Row * width + k] * N[k * width + Col];
      \}
      P[Row * width + Col] = sum;
    \}
\}

\textcolor{keywordtype}{int} main() \{
  std::clock\_t start;

  \textcolor{keywordtype}{bool} equalMultiply1, equalMultiply1unfolded, equalMultiply2,
      equalMultiplyNaive;

  \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} WIDTH\{1024\};
  \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} BLOCK\_SIZE\{16\};
  \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} GRANULARITY\{4\};
  \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} matrix\_size\{WIDTH * WIDTH * \textcolor{keyword}{sizeof}(float)\};
  static\_assert(WIDTH % BLOCK\_SIZE == 0);
  static\_assert(BLOCK\_SIZE % GRANULARITY == 0);
  \textcolor{comment}{// problem with WIDTH > 500}
  \textcolor{comment}{// std::array<float, WIDTH * WIDTH> M, N, P\_cuda, P\_seq;}
  \textcolor{keywordtype}{float} *M = \textcolor{keyword}{new} \textcolor{keywordtype}{float}[WIDTH * WIDTH];
  \textcolor{keywordtype}{float} *N = \textcolor{keyword}{new} \textcolor{keywordtype}{float}[WIDTH * WIDTH];
  \textcolor{keywordtype}{float} *P\_seq = \textcolor{keyword}{new} \textcolor{keywordtype}{float}[WIDTH * WIDTH];
  \textcolor{keywordtype}{float} *P\_cuda = \textcolor{keyword}{new} \textcolor{keywordtype}{float}[WIDTH * WIDTH];

  KernelTime time;

  \textcolor{comment}{// Fill arrays with random values}
  \textcolor{comment}{// fill(N.begin(), N.end());}
  \textcolor{comment}{// fill(M.begin(), M.end());}
  fill(M, M + (WIDTH * WIDTH));
  fill(N, N + (WIDTH * WIDTH));

  \textcolor{keywordflow}{try} \{
    \textcolor{comment}{// Select Device}
    Device dev = Devices::findDevice();
    std::cout << \textcolor{stringliteral}{"===================================\(\backslash\)n"};
    std::cout << \textcolor{stringliteral}{"Selected "} << dev.name() << \textcolor{stringliteral}{" with "}
              << (dev.total\_memory() / 1024) / 1024 << \textcolor{stringliteral}{"mb VRAM\(\backslash\)n"};
    std::cout << \textcolor{stringliteral}{"Kernel Arguments total size: "}
              << ((matrix\_size * 3 + \textcolor{keyword}{sizeof}(size\_t)) / 1024) << \textcolor{stringliteral}{"kb\(\backslash\)n\(\backslash\)n"};
    std::cout << \textcolor{stringliteral}{"Theoretical Bandwith:        "}
              << yacx::theoretical\_bandwidth(dev) << \textcolor{stringliteral}{" GB/s\(\backslash\)n"};

    \textcolor{comment}{// Set kernel string and compile options}

    Source source\{load(\textcolor{stringliteral}{"kernels/matrixMult.cu"})\};
    Options options;
    options.insert(\textcolor{stringliteral}{"--std"}, \textcolor{stringliteral}{"c++14"});
    options.insert(\textcolor{stringliteral}{"--device-debug"});
    options.insertOptions(\hyperlink{classyacx_1_1options_1_1_gpu_architecture}{yacx::options::GpuArchitecture}\{dev\});

    \textcolor{comment}{// Set arguments}

    std::vector<KernelArg> args;
    \textcolor{comment}{// args.emplace\_back(KernelArg\{M.data(), matrix\_size\});}
    \textcolor{comment}{// args.emplace\_back(KernelArg\{N.data(), matrix\_size\});}
    \textcolor{comment}{// args.emplace\_back(KernelArg\{P\_cuda.data(), matrix\_size, true, false\});}
    args.emplace\_back(KernelArg\{M, matrix\_size\});
    args.emplace\_back(KernelArg\{N, matrix\_size\});
    args.emplace\_back(KernelArg\{P\_cuda, matrix\_size, \textcolor{keyword}{true}, \textcolor{keyword}{false}\});
    args.emplace\_back(KernelArg\{\textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{size\_t} *\textcolor{keyword}{>}(&WIDTH)\});

    \textcolor{comment}{// Compile Kernels}

    dim3 grid(WIDTH, WIDTH);
    dim3 block(1, 1);
    Kernel kernelNaive = source.program(\textcolor{stringliteral}{"MatrixMultyNaive"})
                             .compile(options)
                             .configure(grid, block);

    block.x = BLOCK\_SIZE;
    block.y = BLOCK\_SIZE / GRANULARITY;
    grid.x = WIDTH / block.x;
    grid.y = WIDTH / GRANULARITY / block.y;
    \textcolor{comment}{//    std::cout << "get\_global\_size(0): " << block.x * grid.x << std::endl;}
    \textcolor{comment}{//    std::cout << "get\_global\_size(1): " << block.y * grid.y << std::endl;}
    \textcolor{comment}{//    std::cout << "get\_local\_size(0): " << block.x << std::endl;}
    \textcolor{comment}{//    std::cout << "get\_local\_size(1): " << block.y << std::endl;}
    Kernel kernel1 = source.program(\textcolor{stringliteral}{"MatrixMulty1"})
                         .instantiate(BLOCK\_SIZE, GRANULARITY)
                         .compile(options)
                         .configure(grid, block);

    block.x = BLOCK\_SIZE;
    block.y = BLOCK\_SIZE / 4;
    grid.x = WIDTH / block.x;
    grid.y = WIDTH / 4 / block.y;
    Kernel kernel1\_1 = source.program(\textcolor{stringliteral}{"MatrixMulty1unfolded"})
                           .instantiate(BLOCK\_SIZE)
                           .compile(options)
                           .configure(grid, block);

    block.x = BLOCK\_SIZE;
    block.y = BLOCK\_SIZE;
    grid.x = WIDTH / BLOCK\_SIZE;
    grid.y = WIDTH / BLOCK\_SIZE;
    Kernel kernel2 = source.program(\textcolor{stringliteral}{"MatrixMulty2"})
                         .instantiate(BLOCK\_SIZE)
                         .compile(options)
                         .configure(grid, block);

    \textcolor{comment}{// Launch kernels}

    \textcolor{comment}{// CPU single threaded matrix multiplication}
    start = std::clock();
    \textcolor{comment}{// MatrixMulSeq(M.data(), N.data(), P\_seq.data(), WIDTH);}
    MatrixMulSeq(M, N, P\_seq, WIDTH);
    std::cout << \textcolor{stringliteral}{"Time\(\backslash\)u001b[33m[CPU single threaded]\(\backslash\)u001b[0m:   "}
              << (std::clock() - start) / (\textcolor{keywordtype}{double})(CLOCKS\_PER\_SEC / 1000)
              << \textcolor{stringliteral}{" ms"} << std::endl;

    time = kernelNaive.launch(args, dev);
    std::cout << \textcolor{stringliteral}{"Time\(\backslash\)u001b[33m[MatrixMultyNaive]\(\backslash\)u001b[0m:      "}
              << time.total << \textcolor{stringliteral}{" ms\(\backslash\)n"};

    std::cout << \textcolor{stringliteral}{"Effective Bandwith:          "}
              << yacx::effective\_bandwidth(time.launch, args) << \textcolor{stringliteral}{" GB/s\(\backslash\)n"};

    equalMultiplyNaive =
        std::equal(P\_cuda, P\_cuda + (WIDTH * WIDTH), P\_seq, comparator);
    \textcolor{keywordflow}{if} (!equalMultiplyNaive)
      compare(P\_seq, P\_cuda, WIDTH * WIDTH);

    \textcolor{keywordflow}{if} (BLOCK\_SIZE % 4 == 0) \{
      time = kernel1\_1.launch(args, dev);
      std::cout << \textcolor{stringliteral}{"Time\(\backslash\)u001b[33m[MatrixMulty1unfolded]\(\backslash\)u001b[0m:  "}
                << time.total << \textcolor{stringliteral}{" ms\(\backslash\)n"};

      std::cout << \textcolor{stringliteral}{"Effective Bandwith:          "}
                << yacx::effective\_bandwidth(time.launch, args) << \textcolor{stringliteral}{" GB/s\(\backslash\)n"};
      equalMultiply1unfolded =
          std::equal(P\_cuda, P\_cuda + (WIDTH * WIDTH), P\_seq, comparator);
      \textcolor{keywordflow}{if} (!equalMultiply1unfolded)
        compare(P\_seq, P\_cuda, WIDTH * WIDTH);
    \} \textcolor{keywordflow}{else} \{
      equalMultiply1unfolded = \textcolor{keyword}{true};
    \}

    time = kernel1.launch(args, dev);
    std::cout << \textcolor{stringliteral}{"Time\(\backslash\)u001b[33m[MatrixMulty1]\(\backslash\)u001b[0m:          "}
              << time.total << \textcolor{stringliteral}{" ms\(\backslash\)n"};

    std::cout << \textcolor{stringliteral}{"Effective Bandwith:          "}
              << yacx::effective\_bandwidth(time.launch, args) << \textcolor{stringliteral}{" GB/s\(\backslash\)n"};
    equalMultiply1 =
        std::equal(P\_cuda, P\_cuda + (WIDTH * WIDTH), P\_seq, comparator);
    \textcolor{keywordflow}{if} (!equalMultiply1)
      compare(P\_seq, P\_cuda, WIDTH * WIDTH);

    time = kernel2.launch(args, dev);
    std::cout << \textcolor{stringliteral}{"Time\(\backslash\)u001b[33m[MatrixMulty2]\(\backslash\)u001b[0m:          "}
              << time.total << \textcolor{stringliteral}{" ms\(\backslash\)n"};

    std::cout << \textcolor{stringliteral}{"Effective Bandwith:          "}
              << yacx::effective\_bandwidth(time.launch, args) << \textcolor{stringliteral}{" GB/s\(\backslash\)n\(\backslash\)n"};
    equalMultiply2 =
        std::equal(P\_cuda, P\_cuda + (WIDTH * WIDTH), P\_seq, comparator);
    \textcolor{keywordflow}{if} (!equalMultiply2)
      compare(P\_seq, P\_cuda, WIDTH * WIDTH);

  \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception &e) \{
    std::cerr << e.what() << std::endl;
    exit(1);
  \}

  \textcolor{keywordflow}{if} (equalMultiplyNaive && equalMultiply1 && equalMultiply1unfolded &&
      equalMultiply2) \{
    std::cout << \textcolor{stringliteral}{"\(\backslash\)u001b[32meverything was correctly calculated!\(\backslash\)u001b[0m\(\backslash\)n"};
  \} \textcolor{keywordflow}{else} \{
    std::cout << \textcolor{stringliteral}{"\(\backslash\)u001b[31m"};
  \}
  \textcolor{keywordflow}{if} (!equalMultiplyNaive) \{
    std::cout << \textcolor{stringliteral}{"Naive went wrong ;\_;\(\backslash\)n"};
  \}
  \textcolor{keywordflow}{if} (!equalMultiply1) \{
    std::cout << \textcolor{stringliteral}{"Multy1 went wrong ;\_;\(\backslash\)n"};
  \}
  \textcolor{keywordflow}{if} (!equalMultiply1unfolded) \{
    std::cout << \textcolor{stringliteral}{"Multy1unfolded went wrong ;\_;\(\backslash\)n"};
  \}
  \textcolor{keywordflow}{if} (!equalMultiply2) \{
    std::cout << \textcolor{stringliteral}{"Multy2 went wrong ;\_;\(\backslash\)n"};
  \}

  std::cout << \textcolor{stringliteral}{"\(\backslash\)u001b[0m==================================="} << std::endl;

  \textcolor{comment}{// Free resources}

  \textcolor{keyword}{delete}[] M;
  \textcolor{keyword}{delete}[] N;
  \textcolor{keyword}{delete}[] P\_seq;
  \textcolor{keyword}{delete}[] P\_cuda;

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCodeInclude}
 